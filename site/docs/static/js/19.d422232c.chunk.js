webpackJsonp([19],{53:function(n,e){n.exports="## What's Store?\n\nStore is Omi's built-in centralized data warehouse, which solves and provides the following problems and capabilities:\n\n* Component Tree Data Sharing\n* Data Change Updates Dependent Components on Demand\n\n![](https://github.com/Tencent/omi/raw/master/assets/store.jpg)\n\n## A piece of code is completely ready for Store\n\n```jsx\nimport { render, WeElement, define } from 'omi'\n\ndefine('my-counter', class extends WeElement {\n  use = ['count', 'adding']\n\n  addIfOdd = () => {\n    if (this.store.data.count % 2 !== 0) {\n      this.store.add()\n    }\n  }\n\n  addAsync = () => {\n    this.store.data.adding = true\n    setTimeout(() => {\n      this.store.data.adding = false\n      this.store.add()\n    }, 1000)\n  }\n\n  render() {\n    const store = this.store\n    const { data, add, sub } = store\n    return (\n      <p>\n        Clicked: {data.count} times\n        {' '}\n        <button onClick={add}>+</button>\n        {' '}\n        <button onClick={sub}>-</button>\n        {' '}\n        <button disabled={data.count % 2 === 0} onClick={this.addIfOdd}>\n          Add if odd\n        </button>\n        {' '}\n        <button disabled={data.adding} onClick={this.addAsync}>\n          Add async\n        </button>\n      </p>\n    )\n  }\n})\n\nrender(<my-counter />, 'body', new class Store {\n  data = {\n    count: 0,\n    adding: false\n  }\n  sub = () => {\n    this.data.count--\n  }\n  add = () => {\n    this.data.count++\n  }\n})\n```\n\n* Declare a dependent path by `use` or `useSelf`(useSelf will update self only, exclude children components).\n* `store` injects all components from the root node through the third parameter of render.\n\nHere is a complicated example of `use'.\n\nData of store:\n\n```json\n{\n  count: 0,\n  arr: ['china', 'tencent'],\n  motto: 'I love omi.',\n  userInfo: {\n    firstName: 'dnt',\n    lastName: 'zhang',\n    age: 18\n  }\n}\n```\n\nUse and compute grammar:\n\n```jsx\nuse = [\n  'count', //Direct string, accessible through this.using[0] \n  'arr[0]', //It also supports path, which is accessible through this.using[1]\n  'motto',\n  'userInfo',\n  { name: 'arr[1]' } //{ alias: path }\uff0caccessible through this.using.name\n]\n\ncompute = {\n  reverseMotto() {\n    return this.motto.split('').reverse().join('')\n  },\n  fullName() {\n    return this.userInfo.firstName + this.userInfo.lastName\n  }\n}\n```\n\nLet's look at the use of JSX:\n\n```jsx\n...\n...\nrender() {\n  return (\n    <div>\n      <button onClick={this.sub}>-</button>\n      <span>{this.using[0]}</span>\n      <button onClick={this.add}>+</button>\n      <div>\n        <span>{this.using[1]}</span>\n        <button onClick={this.rename}>rename</button>\n      </div>\n      <div>{this.computed.reverseMotto}</div><button onClick={this.changeMotto}>change motto</button>\n      <div>{this.using.name}</div>\n      <div>{this.using[3]}</div>\n      <div>\n        {this.computed.fullName}\n        <button onClick={this.changeFirstName}>change first name</button>\n      </div>\n    </div>\n  )\n}\n...\n...\n```\n\nWithout alias, you can also access it directly through `this.store.data.xxx'.\n\n### Path hit rule\n\n| Proxy Path | path in use   | update |\n| ---------- | ---------- | -------- |\n| abc        | abc        | true     |\n| abc[1]     | abc        | true     |\n| abc.a      | abc        | true     |\n| abc        | abc.a      | false   |\n| abc        | abc[1]     | false   |\n| abc        | abc[1].c   | false   |\n| abc.b      | abc.b      | true     |\n\nThe above can be updated by hitting only one condition!\n\nSummary: As long as the path of the injected component is equal to that declared in use or under one of the path sub-nodes declared in use, it will be updated!\n\n### Destructuring assignment\n\n```jsx\nimport { define, WeElement } from 'omi'\nimport '../my-list'\n\ndefine('my-sidebar', class extends WeElement {\n  static css = require('./_index.css')\n\n  use = [\n    'menus',\n    'sideBarShow',\n    'lan'\n  ]\n\n  render() {\n    const [menus, sideBarShow, lan] = this.using\n\n    return (\n      <div class={`list${sideBarShow ? ' show' : ''}`}>\n        {menus[lan].map((menu, index) => (\n          <my-list menu={menu} index={index} />\n        ))}\n      </div>\n    )\n  }\n})\n```\n\nHere is an example of using the ES2015+ Grammar `const [xx, xxx] = xxxx` for fast assignment.\n\n\n## Dynamic use\n\nIf you don't want the same components to have the same dependencies, you can use dynamic use:\n\n```js\nuse() {\n  return [\n    'a.b',\n    'c[1].d',\n    `e.f.${xxx}.d[${index}]`\n  ]\n}\n```\n\n## Functional style \n\n```jsx\nimport { define, render } from 'omi'\n\nclass Store {\n  data = {\n    count: 1\n  }\n  sub = () => {\n    this.data.count--\n  }\n  add = () => {\n    this.data.count++\n  }\n}\n\ndefine('my-counter', ['count'], _ => (\n  <div>\n    <button onClick={_.store.sub}>-</button>\n    <span>{_.store.data.count}</span>\n    <button onClick={_.store.add}>+</button>\n  </div>\n))\n\nrender(<my-counter />, 'body', new Store)\n```\n\nVery flexible!\n"}});
//# sourceMappingURL=19.d422232c.chunk.js.map